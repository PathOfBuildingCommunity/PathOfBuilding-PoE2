if not loadStatFile then
	dofile("statdesc.lua")
end
loadStatFile("stat_descriptions.csd")

function table.containsId(table, element)
  for _, value in pairs(table) do
    if value.Id == element then
      return true
    end
  end
  return false
end

local function writeMods(outName, condFunc)
	local out = io.open(outName, "w")
	out:write('-- This file is automatically generated, do not edit!\n')
	out:write('-- Item data (c) Grinding Gear Games\n\nreturn {\n')
	for mod in dat("Mods"):Rows() do
		if condFunc(mod) then
			local stats, orders = describeMod(mod)
			if #orders > 0 then
				out:write('\t["', mod.Id, '"] = { ')
				if mod.GenerationType == 1 then
					out:write('type = "Prefix", ')
				elseif mod.GenerationType == 2 then
					out:write('type = "Suffix", ')
				elseif mod.GenerationType == 3 then
					if mod.Domain == 1 and mod.Id:match("^Synthesis") then
						out:write('type = "Synthesis", ')
					elseif mod.Domain == 16 then
						out:write('type = "DelveImplicit", ')
					end
				elseif mod.GenerationType == 5 then
					out:write('type = "Corrupted", ')
				end
				out:write('affix = "', mod.Name, '", ')
				for index, value in pairs(mod.Family) do
					if string.find(value.Id, "LocalDisplayNearbyEnemy") and #stats > index and #orders > index then
						table.remove(stats, index)
						table.remove(orders, index)
						break
					end
 				end
				out:write('"', table.concat(stats, '", "'), '", ')
				out:write('statOrderKey = "', table.concat(orders, ','), '", ')
				out:write('statOrder = { ', table.concat(orders, ', '), ' }, ')
				out:write('level = ', mod.Level, ', group = "', mod.Type.Id, '", ')
				out:write('weightKey = { ')
				local GoldModPrices = dat("GoldModPrices"):GetRow("Id", dat("Mods"):GetRow("Id", mod.Id))
				if GoldModPrices then
					local count = 0
					for _, tag in ipairs(GoldModPrices.SpawnTags) do
						out:write('"', tag.Id, '", ')
						count = count + 1
					end
					-- no spawntags exist for flask/charm mods
					if count == 0 then 
						-- flasks/charms
						if mod.Domain == 2 then 
							if mod.Type.Id == "FlaskExtraLifeCostsMana" or mod.Type.Id == "FlaskIncreasedRecoveryOnLowLife" or mod.Type.Id == "FlaskHealsMinions" then 
								out:write('"life_flask", ')
							elseif mod.Type.Id == "FlaskExtraManaCostsLife" or mod.Type.Id == "FlaskIncreasedRecoveryOnLowMana" then 
								out:write('"mana_flask", ')
							elseif mod.Id:match("^Flask") then 
								out:write('"flask", ') 
							elseif mod.Id:match("^Charm") then
								out:write('"utility_flask", ') 
							end
							out:write('"default" }, ')
							out:write('weightVal = { 1, 0 }, ')
						end
					else
						out:write('}, ')
						out:write('weightVal = { ', table.concat(GoldModPrices.SpawnWeights, ', '), ' }, ')
					end
				else
					-- jewels
					if mod.Domain == 11 then
						local strTypes = {
							-- prefixes
							"AreaOfEffect",
							"GlobalPhysicalDamageReductionRatingPercent",
							"ArmourBreak",
							"Attackdamage",
							"BaseChanceToBleed",
							"IncreasedBlockChance",
							"DamagevsArmourBrokenEnemies",
							"ElementalDamagePercent",
							"ExertedAttackDamage",
							"FireDamagePercentage",
							"FireResistancePenetration",
							"IgniteEffect",
							"IncreasedMaceDamageForJewel",
							"MaximumRage",
							"MeleeDamage",
							"MinionAreaOfEffect",
							"MinionLife",
							"PhysicalDamagePercent",
							"ShieldArmourIncrease",
							"BleedDotMultiplier",
							"ThornsDamageIncrease",
							"TotemDamageForJewel",
							"IncreasedTotemLife",
							"WarcryEffect",
							"WarcryDamage",
							-- suffixes
							"ArmourBreakDuration", 
							"BleedDuration",
							"IgniteChanceIncrease",
							"SkillEffectDuration",
							"KnockbackDistance",
							"LifeCost",
							"LifeLeechAmount",
							"LifeRegenerationRate",
							"MaceStun",
							"MaximumFireResist",
							"MinionPhysicalDamageReduction",
							"RageOnHit",
							"GainRageWhenHit",
							"StunDamageIncrease",
							"IncreasedStunThreshold",
							"SummonTotemCastSpeed",
							"WarcryCooldownSpeed",
							"WarcrySpeed",
							"WeaponSwapSpeed",
						}
						local dexTypes = {
							-- prefixes
							"IncreasedAccuracyPercent",
							"AilmentEffect",
							"AttackDamage",
							"BlindEffect",
							"DamageVsRareOrUnique",
							"BowIncreasedAccuracyRating",
							"IncreasedBowDamageForJewel",
							"CharmDamageWhileUsing",
							"CriticalAilmentEffect",
							"CrossbowDamage",
							"ElementalDamagePercent",
							"GlobalEvasionRatingPercent",
							"HeraldDamage",
							"LightningDamagePercentage",
							"LightningResistancePenetration",
							"MarkEffect",
							"PoisonEffect",
							"ProjectileDamage",
							"ProjectileSpeed",
							"IncreasedStaffDamageForJewel",
							"QuiverModifierEffect",
							"ShockEffect",
							-- suffixes
							"AilmentChance",
							"IncreasedAilmentThreshold",
							"AttackCriticalStrikeChance",
							"AttackCriticalStrikeMultiplier",
							"IncreasedAttackSpeed",
							"AttacksBlindOnHitChance",
							"BowAttackSpeedForJewel",
							"ChainFromTerrain",
							"CharmDuration",
							"CharmChargesGained",
							"GlobalCooldownRecovery",
							"CrossbowReloadSpeed",
							"CrossbowSpeed",
							"DamagingAilmentDuration",
							"DazeBuildup",
							"DebuffTimePassed",
							"ElementalAilmentDuration",
							"FasterAilmentDamageForJewel",
							"IncreasedFlaskChargesGained",
							"FlaskDuration",
							"ForkingProjectiles",
							"GlobalFlaskLifeRecovery",
							"LifeFlaskChargePercentGeneration",
							"FlaskManaRecovery",
							"ManaFlaskChargePercentGeneration",
							"ManaLeechAmount",
							"MarkCastSpeed",
							"MarkDuration",
							"MaximumLightningResistance",
							"MovementVelocity",
							"ChanceToPierce", 
							"PinBuildup", 
							"BaseChanceToPoison", 
							"PoisonDuration",
							"QuarterstaffFreezeBuildup",
							"StaffAttackSpeedForJewel",
							"ShockChanceIncrease",
							"ShockDuration",
							"SlowPotency",
							"IncreasedStunThresholdIfNoRecentStun"
						}
						local intTypes = {
							-- prefixes
							"AilmentEffect",
							"AreaOfEffect",
							"AuraEffectForJewel",
							"IncreasedChaosDamage",
							"ColdDamagePercentage", 
							"ColdResistancePenetration",
							"DamageIfConsumedCorpse",
							"CriticalAilmentEffect",
							"CurseAreaOfEffect",
							"CurseEffectivenessForJewel",
							"ElementalDamagePercent",
							"GlobalEnergyShieldPercent",
							"EnergyShieldDelay",
							"EnergyShieldRegeneration",
							"FocusEnergyShield",
							"IgniteEffect",
							"MinionAccuracyRatingForJewel",
							"MinionDamage",
							"OfferingLife",
							"ShockEffect",
							"WeaponSpellDamage",
							"DamageWithTriggeredSpells",
							"WitheredEffect",
							-- suffixes
							"AilmentChance",
							"IncreasedCastSpeed",
							"IncreasedChillDuration",
							"CriticalStrikeChance",
							"CriticalStrikeMultiplier",
							"SpellCritMultiplierForJewel",
							"CurseDelay",
							"BaseCurseDuration",
							"DamagingAilmentDuration",
							"DebuffTimePassed",
							"EnergyGeneration",
							"FasterAilmentDamageForJewel",
							"FreezeDamageIncrease",
							"FreezeThreshold",
							"IgniteChanceIncrease",
							"SkillEffectDuration",
							"MaximumLifeOnKillPercent",
							"LifeRecoupForJewel",
							"ManaGainedOnKillPercentage",
							"ManaRegeneration",
							"MaximumColdResist",
							"MinionAttackSpeedAndCastSpeed",
							"MinionChaosResistance",
							"MinionCriticalStrikeChanceIncrease",
							"MinionCriticalStrikeMultiplier",
							"MinionElementalResistance",
							"OfferingDuration",
							"QuarterstaffFreezeBuildup",
							"ShockChanceIncrease",
							"ShockDuration",
							"SpellCriticalStrikeChance",
							"StunThresholdfromEnergyShield"
						}
						local keysCount = 0
						if mod.Id:match("JewelRadius") then
							if isValueInArray(strTypes, mod.Type.Id) then
								out:write('"str_radius_jewel", ')
								keysCount = keysCount + 1
							end
							if isValueInArray(dexTypes, mod.Type.Id) then
								out:write('"dex_radius_jewel", ')
								keysCount = keysCount + 1
							end
							if isValueInArray(intTypes, mod.Type.Id) then
								out:write('"int_radius_jewel", ')
								keysCount = keysCount + 1
							end
							if keysCount == 0 then
								out:write('"radius_jewel", ')
								keysCount = keysCount + 1
							end
						else 
							if isValueInArray(strTypes, mod.Type.Id) then
								out:write('"strjewel", ')
								keysCount = keysCount + 1
							end
							if isValueInArray(dexTypes, mod.Type.Id) then
								out:write('"dexjewel", ')
								keysCount = keysCount + 1
							end
							if isValueInArray(intTypes, mod.Type.Id) then
								out:write('"intjewel", ')
								keysCount = keysCount + 1
							end
						end
						out:write('"default" }, ')
						out:write('weightVal = { ', string.rep("1, ", keysCount), '0 }, ')
					else
						out:write('}, ')
						out:write('weightVal = { ', table.concat(mod.SpawnWeights, ', '), ' }, ')
					end
				end
				if mod.GenerationWeightTags[1] then
					-- make large clusters only have 1 notable suffix
					if mod.GenerationType == 2 and mod.Tags[1] and outName == "../Data/ModJewelCluster.lua" and mod.Tags[1].Id == "has_affliction_notable" then
						out:write('weightMultiplierKey = { "has_affliction_notable2", ')
						for _, tag in ipairs(mod.GenerationWeightTags) do
							out:write('"', tag.Id, '", ')
						end
						out:write('}, ')
						out:write('weightMultiplierVal = { 0, ', table.concat(mod.GenerationWeightValues, ', '), ' }, ')
						if mod.Tags[1] then
							out:write('tags = { "has_affliction_notable2", ')
							for _, tag in ipairs(mod.Tags) do
								out:write('"', tag.Id, '", ')
							end
							out:write('}, ')
						end
					else
						out:write('weightMultiplierKey = { ')
						for _, tag in ipairs(mod.GenerationWeightTags) do
							out:write('"', tag.Id, '", ')
						end
						out:write('}, ')
						out:write('weightMultiplierVal = { ', table.concat(mod.GenerationWeightValues, ', '), ' }, ')
						if mod.Tags[1] then
							out:write('tags = { ')
							for _, tag in ipairs(mod.Tags) do
								out:write('"', tag.Id, '", ')
							end
							out:write('}, ')
						end
					end
				end
				out:write('modTags = { ', stats.modTags, ' }, ')
				out:write('},\n')
			else
				print("Mod '"..mod.Id.."' has no stats")
			end
		end
		::continue::
	end
	out:write('}')
	out:close()
end



writeMods("../Data/ModItem.lua", function(mod)
	return mod.Domain == 1 and (mod.GenerationType == 1 or mod.GenerationType == 2 or mod.GenerationType == 3 or mod.GenerationType == 5)
	and (mod.Family[1] and mod.Family[1].Id ~= "AuraBonus" or not mod.Family[1]) and (not mod.Id:match("Cowards"))
end)
writeMods("../Data/ModFlask.lua", function(mod)
	return mod.Domain == 2 and (mod.GenerationType == 1 or mod.GenerationType == 2) and mod.Id:match("^Flask")
end)
writeMods("../Data/ModCharm.lua", function(mod)
	return mod.Domain == 2 and ((mod.GenerationType == 1 and mod.Id:match("^Charm"))
	or (mod.GenerationType == 2 and not mod.Id:match("Immunity"))) 
end)
writeMods("../Data/ModJewel.lua", function(mod)
	return (mod.Domain == 11 and (mod.GenerationType == 1 or mod.GenerationType == 2)) or (mod.Domain == 21 and mod.GenerationType == 3)
end)


print("Mods exported.")
